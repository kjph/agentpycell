""" ABM: Agent Based Modelling

The base class Cell provides one method update() that will be called
on every tick.

Ticks are generated by Grids - a collection of Cell object
"""

import abc
import copy

from . import utils

class SimpleCell(abc.ABC):
    """ The simple cell only exposes an .update method
    which should be called upon every tick. This method
    is a function only of its direct neighbours.
    """

    def __init__(self, initial_conditions=None):
        pass

    @abc.abstractmethod
    def update(self, neighbours):
        pass

class SimpleGrid(utils.list2):
    """ A simple grid is an uniform 2D grid of SimpleCells

    Args:
        width (int): The number of cells along the x-dimension
        height (int): The number of cells along the y-dimension
        cell (patraffic.SimpleCell): The cell class to use
        real_time (boolean): When True, the grid tick method will be realtime
    """

    def __init__(self, row, col, cell, real_time=True, initial_conditions=None):

        self._dim = (row, col)
        self._cell_kls = cell

        if initial_conditions is None:
            cell_grid = utils.list2(row, col)
            for _, (r,c) in cell_grid.items():
                cell_grid[r][c] = self._cell_kls()
        else:
            cell_grid = utils.list2(row, col)
            for _, (r,c) in cell_grid.items():
                init_val = initial_conditions[r][c]
                cell_grid[r][c] = self._cell_kls(initial_conditions=init_val)

        self._array = cell_grid._array

        if real_time:
            self.tick_type = 'realtime'
        else:
            self.tick_type = 'staged'

    @property
    def tick_type(self):
        return self._tick_type

    @tick_type.setter
    def tick_type(self, val):
        if val == 'realtime':
            self._tick_method = self.tick_realtime
            self.set_sweep('dr')
        elif val == 'staged':
            self._tick_method = self.tick_staged
            self._stage = copy.deepcopy(self._array)

    def tick(self, *args, **kwargs):
        self._tick_method(*args, **kwargs)

    def get_neighbours(self, r, c):
        """ Returns the subset that surrounds point (r,c). Note that the start 
        position of this subset is always up one, left one. But if (r,c) is on
        a boundary then:
            - 'up one, left one' will give a negative index, hence start uses
              max()
            - the nrow's or ncol's will be less hence the ternary operators
        """

        start = (max(0, r-1), max(0, c-1))

        maxr, maxc = self.dim
        nrow = 2 if (r == 0 or r == maxr-1) else 3
        ncol = 2 if (c == 0 or c == maxc-1) else 3

        neighbours = self.subset(start, nrow, ncol)
        this_r = 0 if (r == 0) else 1
        this_c = 0 if (c == 0) else 1

        neighbours[this_r][this_c] = None
        return neighbours

    def tick_staged(self, *args, **kwargs):
        for _, (r, c) in self.items():
            cell = self._stage[r][c]
            cell.update(self.get_neighbours(r, c), *args, **kwargs)

        self._array = copy.deepcopy(self._stage)

    def tick_realtime(self, *args, **kwargs):
        for cell, (x, y) in self.sweep():
            cell.update(self.get_neighbours(r, c), *args, **kwargs)
