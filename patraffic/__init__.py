""" ABM: Agent Based Modelling

The base class Cell provides one method update() that will be called
on every tick.

Ticks are generated by Grids - a collection of Cell object
"""

import abc

from . import utils

class SimpleCell(abc.ABC):
    """ The simple cell only exposes an .update method
    which should be called upon every tick. This method
    is a function only of its direct neighbours.
    """

    @abc.abstractmethod
    def update(self, neighbours):
        pass

class SimpleGrid(utils.list2):
    """ A simple grid is an uniform 2D grid of SimpleCells

    Args:
        width (int): The number of cells along the x-dimension
        height (int): The number of cells along the y-dimension
        cell (patraffic.SimpleCell): The cell class to use
        real_time (boolean): When True, the grid tick method will be realtime
    """

    def __init__(self, row, col, cell, real_time=True, initial_conditions=None):

        self._dim = (row, col)
        self._cell_kls = cell

        if initial_conditions is None:
            cell_grid = [[init for c in range(col)] for r in range(row)]
            for c in range(col):
                for r in range(row):
                    cell_grid[r][c] = self._cell_kls()
        else:
            cell_grid = utils.list2(row, col)
            for _, (r,c) in cell_grid.items():
                init_val = initial_conditions[r][c]
                cell_grid[r][c] = self._cell_kls(initial_conditions=init_val)

        self._array = cell_grid._array

        if real_time:
            self.tick_type = 'realtime'
        else:
            self.tick_type = 'staged'

    @property
    def tick_type(self):
        return self._tick_type

    @tick_type.setter
    def tick_type(self, val):
        if val == 'realtime':
            self._tick_method = self.tick_realtime
            self.set_sweep(direction)
        elif val == 'staged':
            self._tick_method = self.tick_staged
            self._stage = self._array

    def tick(self, *args, **kwargs):
        self._tick_method(*args, **kwargs)

    def get_neighbours(self, r, c):

        _r, _c = self.dim

        start = (max(0, r-1), max(0, c-1))      
        nrow = 2 if (r == 0 or r == _r-1) else 3
        ncol = 2 if (c == 0 or c == _c-1) else 3
        
        neighbours = self.subset(start, nrow, ncol)
        neighbours[1][1] = None
        return neighbours

    def tick_staged(self, *args, **kwargs):
        for cell, (r, c) in self.items():
            cell.update(self.get_neighbours(r, c), *args, **kwargs)

        self._array = self._stage

    def tick_realtime(self, *args, **kwargs):
        for cell, (x, y) in self.sweep():
            cell.update(self.get_neighbours(r, c), *args, **kwargs)
