""" AGM: Agent Based Modelling

The base class Cell provides one method update() that will be called
on every tick.

Ticks are generated by Grids - a collection of Cell object
"""

import abc

class SimpleCell(abc.ABC):
    """ The simple cell only exposes an .update method
    which should be called upon every tick. This method
    is a function only of its direct neighbours.
    """

    @abc.abstractmethod
    def update(self, neighbours):
        pass

class SimpleGrid(object):
    """ A simple grid is an uniform 2D grid of SimpleCells

    Args:
        width (int): The number of cells along the x-dimension
        height (int): The number of cells along the y-dimension
        cell (patraffic.SimpleCell): The cell class to use
        real_time (boolean): When True, the grid tick method will be realtime
    """

    def __init__(self, width, height, cell=SimpleCell, real_time=True):

        self._width = width
        self._height = height
        self._cell_kls = cell
        self._grid = [[self._cell_kls() for y in range(self._height)] for x in range(self._width)]

        # This attribute is only used for staged sweeps
        self._stage = self._grid

        if real_time:
            self.set_sweep_realtime()
        else:
            self.set_sweep_staged()

    def reset_grid(self):
        """ Re-initiates all cell members
        """
        self._grid = [[self._cell_kls() for y in range(self._height)] for x in range(self._width)]

    @property
    def size(self):
        """ Returns the dimensions of the grid
        """

        return (self._width, self._height)

    def get_cell(self, x, y):
        return self._grid[x][y]

    def set_sweep_staged(self):
        """ When this is called, the grid will tick across all the cells
        saving results to a staged cell, completing all the updates first
        before finalising results.
        """

        self._tick_method = self.tick_staged
        self._y_sweep = [y for y in range(self._height)]
        self._x_sweep = [x for x in range(self._width)]

    def set_sweep_realtime(self, x_first=False, x_asc=True, y_asc=True):
        """ When this is called, the grid will tick across the all the cells
        as dictated by the x_first, x_asc, and y_asc booleans; updating each 
        cell and using the most recent updates intra-iteration
        
        Nb. asc = ascending
        """

        self._tick_method = self.tick_realtime

        self._x_first = x_first
        
        if y_asc:
            self._y_sweep = [y for y in range(self._height)]
        else:
            self._y_sweep = [y for y in reversed(range(self._height))]

        if x_asc:
            self._x_sweep = [x for x in range(self._width)]
        else:
            self._x_sweep = [x for x in reversed(range(self._width))]

    def tick(self, *args, **kwargs):
        self._tick_method(*args, **kwargs)

    def tick_staged(self, *args, **kwargs):
        for y in self._y_sweep:
            for x in self._x_sweep:

                neighbours = self._grid[max(0, x-1):x+2]
                neighbours = [[c for c in w[max(0, y-1):y+2]] for w in neighbours]
                self._stage[x][y].update(neighbours, *args, **kwargs)

        self._grid = self._stage

    def tick_realtime(self, *args, **kwargs):

        if self._x_first:
            for y in self._y_sweep:
                for x in self._x_sweep:

                    neighbours = self._grid[max(0, x-1):x+2]
                    neighbours = [[c for c in w[max(0, y-1):y+2]] for w in neighbours]
                    self._grid[x][y].update(neighbours, *args, **kwargs)
        else:
            for x in self._x_sweep:
                for y in self._y_sweep:

                    neighbours = self._grid[max(0, x-1):x+2]
                    neighbours = [[c for c in w[max(0, y-1):y+2]] for w in neighbours]
                    self._grid[x][y].update(neighbours, *args, **kwargs)