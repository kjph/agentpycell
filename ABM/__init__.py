""" AGM: Agent Based Modelling

The base class Cell provides one method update() that will be called
on every tick.

Ticks are generated by Grids - a collection of Cell object
"""

class Cell(object):

    def __init__(self):
        pass

    def update(self, neighbours):
        pass

class Grid(object):

    def __init__(self, row, col, cell=Cell, real_time=True):

        self._width = row
        self._height = col
        self._cell_kls = cell
        self._grid = [[self._cell_kls() for y in range(self._height)] for x in range(self._width)]

        self._stage = self._grid

        if real_time:
            self.set_sweep_realtime()
        else:
            self.set_sweep_staged()

    def reset_grid(self):
        self._grid = [[self._cell_kls() for y in range(self._height)] for x in range(self._width)]

    @property
    def size(self):
        return (self._width, self._height)

    def get_cell(self, x, y):
        return self._grid[x][y]

    def set_sweep_staged(self):
        """ When this is called, the grid will tick across all the cells
        saving results to a staged cell, completing all the updates first
        before finalising results.
        """

        self._tick_method = self.tick_staged
        self._y_sweep = [y for y in range(self._height)]
        self._x_sweep = [x for x in range(self._width)]

    def set_sweep_realtime(self, x_first=False, x_asc=True, y_asc=True):
        """ When this is called, the grid will tick across the all the cells
        as dictated by the x_first, x_asc, and y_asc booleans; updating each 
        cell and using the most recent updates intra-iteration
        
        Nb. asc = ascending
        """

        self._tick_method = self.tick_realtime

        self._x_first = x_first
        
        if y_asc:
            self._y_sweep = [y for y in range(self._height)]
        else:
            self._y_sweep = [y for y in reversed(range(self._height))]

        if x_asc:
            self._x_sweep = [x for x in range(self._width)]
        else:
            self._x_sweep = [x for x in reversed(range(self._width))]

    def tick(self, *args, **kwargs):
        self._tick_method(*args, **kwargs)

    def tick_staged(self, *args, **kwargs):
        for y in self._y_sweep:
            for x in self._x_sweep:

                neighbours = self._grid[max(0, x-1):x+2]
                neighbours = [[c for c in w[max(0, y-1):y+2]] for w in neighbours]
                self._stage[x][y].update(neighbours, *args, **kwargs)

        self._grid = self._stage

    def tick_realtime(self, *args, **kwargs):

        if self._x_first:
            for y in self._y_sweep:
                for x in self._x_sweep:

                    neighbours = self._grid[max(0, x-1):x+2]
                    neighbours = [[c for c in w[max(0, y-1):y+2]] for w in neighbours]
                    self._grid[x][y].update(neighbours, *args, **kwargs)
        else:
            for x in self._x_sweep:
                for y in self._y_sweep:

                    neighbours = self._grid[max(0, x-1):x+2]
                    neighbours = [[c for c in w[max(0, y-1):y+2]] for w in neighbours]
                    self._grid[x][y].update(neighbours, *args, **kwargs)

    def print_grid(self, start='\t'):

        for y in range(self._height):
            line = start
            for x in range(self._width):
                line += ' {}'.format(self._grid[x][y].val)

            print(line)
